1、缓存位置：
依次查找缓存且都没有命中的时候，才会去请求网络
（1）Service Worker 浏览器缓存
（2）Memory Cache 内存
（3）Disk Cache 存储在硬盘中的缓存
（4）Push Cache 
（5）网络请求

2、Service Worker
这个缓存与浏览器内建的缓存机制不同，它可以让我们自由控制哪些文件需要缓存、如何匹配缓存、如何读取缓存、并且缓存是持久性的。

3、Memory Cache
内存中的缓存，读取内存中的数据肯定比磁盘快。

4、Disk Cache
容量和存储时效性上比内存好

5、Push Cache
只在会话（Session）中存在，一旦会话结束就被释放

6、缓存策略
浏览器的缓存策略分为两种：强缓存和协商缓存。
缓存策略是通过HTTP Header来实现的。
6.1强缓存
强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code为 200
Expires：HTTP/1 表示会在某一个新鲜时间之后缓存过期。但是如果修改了本地时间，可能会造成缓存失效
Cache-control：HTTP/1.1 30 秒后过期，需要再次请求。 设置：max-age=30

6.2协商缓存
如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag
*Last-Modified 和 If-Modified-Since：
本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。
但是Last-Modified存在一些弊端：
如果在本地的文件夹中找到你缓存的文件并打开，尽管你没有修改，但是 Last-Modified 还是会被修改，这时服务器认为没有命中缓存还是会发送新的资源；
因为它是以秒为单位的，如果在无法感知的时间修改，服务器不会返回正确的资源。

*ETag 和 If-None-Match：
etag类似文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问ETag 是否变动，有变动的话就将新的资源发送回来。


7、缓存实际场景
频繁变动的资源
对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
