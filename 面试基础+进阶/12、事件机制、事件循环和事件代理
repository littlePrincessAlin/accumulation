1、事件流：
 捕获-> 触发目标注册的事件函数->冒泡
捕获：当鼠标点击或触发dom事件时，浏览器会从根结点从外往内进行事件传播；
冒泡：与捕获相反，从内往外
addEventListener的第三个参数，true：捕获 false：冒泡

2、阻止事件流
event.preventDefault()：不用执行一些和事件关联的默认动作
event.stopPropagation()/ event.cancelBubble = true：阻止事件冒泡。

事件的阻止在不同浏览器有不同处理： IE下使用return false ；其他使用 event.preventDefault()

stopImmediatePropagation：这个与stopPropagation的区别是，如果一个dom注册了两个事件，它也能做到阻止它以下的方法触发；

3、事件委托
当有许多个li，每个li有相同的点击事件。如果为每个li添加点击事件，会引起浏览器重绘与重排次数过多。所以需要将事件委托到父节点上。
事件委托是利用冒泡来实现的。

4、事件循环
https://zhuanlan.zhihu.com/p/33058983
js是单线程的，为什么？
  js是非阻塞单线程语言。和浏览器交互使用的。js在执行的时候，都只有一个主线程来处理所有任务。
  原因 - 避免 DOM 渲染的冲突： 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom
  而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。
web worker技术

进程与线程？
进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间
把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁

event loop机制？
  （1）当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行；
  （2）在一个事件循环中，异步事件返回结果后会被放到一个任务队列中，这个事件实际上会被放到对应的宏任务队列或者微任务队列中去；
  （3）在当前执行栈为空的时候，主线程会 查看微任务队列，依次执行队列中事件对应的回调，直到微任务队列为空；
  （4）然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

常见的宏任务和微任务：
  宏任务：setTimeout、绑定事件
  微任务：Promise.then、

node环境下的事件循环机制？
外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段...
timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
idle, prepare: 这个阶段仅在内部使用，可以不必理会。
poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
check: setImmediate()的回调会在这个阶段执行。
close callbacks: 例如socket.on('close', ...)这种close事件的回调。
