//什么是设计模式？

//设计模式的类型：
//结构型模式：识别系统中组件间的简单关系来简化系统的设计
//创建型模式：
//行为型模式

https://cloud.tencent.com/developer/article/1627336

1、外观模式
解释：它就是把多个子系统的复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的api。
例如jquery就把原声的dom操作进行了抽象和封装，并消除了浏览器之间的兼容性问题。
优点：减少系统相互依赖、提高了灵活性和安全性
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

比如我们可以应用外观模式封装一个统一的dom元素事件绑定/取消方法，用于兼容不同版本的浏览器和更方便的调用：

// 绑定事件
function addEvent(element, event, handler) {
  if (element.addEventListener) {
    element.addEventListener(event, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent('on' + event, handler);
  } else {
    element['on' + event] = fn;
  }
}

// 取消绑定
function removeEvent(element, event, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(event, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent('on' + event, handler);
  } else {
    element['on' + event] = null;
  }
}

2、代理模式
比如有一个股票查询价格接口，调用这个接口需要的时间比较久，我们不希望每次都去请求远程接口，而是增加缓存机制，当有缓存时直接从缓存中获取，否则再去请求远程接口。

3、工厂模式
当构造函数过多不方便管理时，并且需要创建的对象之间存在某些关联时，可以使用工程模式。
 // 一些汽车构造函数
function SuzukiCar(color) {
  this.color = color;
  this.brand = 'Suzuki';
}

function BMWCar(color) {
  this.color = color;
  this.brand = 'BMW';
}

// 汽车品牌枚举
const BRANDS = {
  suzuki: 1,
  honda: 2,
  bmw: 3
}
/**
 * 汽车工厂
 */
function CarFactory() {
  this.create = function (brand, color) {
    switch (brand) {
      case BRANDS.suzuki:
        return new SuzukiCar(color);
      case BRANDS.honda:
        return new HondaCar(color);
      case BRANDS.bmw:
        return new BMWCar(color);
      default:
        break;
    }
  }
}
const carFactory = new CarFactory();
const cars = [];

cars.push(carFactory.create(BRANDS.suzuki, 'brown'));
....

4、单例模式

5、策略模式

6、迭代器模式

7、观察者模式/又名：发布订阅模式
被观察者维护一组观察者，当被观察对象状态改变时，通过调用观察者某个方法将这些变化通知给观察者。
比如dom元素绑定事件：
target.addEventListener(type, listener [, options]);
target被观察者；listener观察者；
实现：
// 被观察者
function Subject() {
  this.observers = [];
}

Subject.prototype = {
  // 订阅
  subscribe: function (observer) {
    this.observers.push(observer);
  },
  // 取消订阅
  unsubscribe: function (observerToRemove) {
    this.observers = this.observers.filter(observer => {
      return observer !== observerToRemove;
    })
  },
  // 事件触发
  fire: function () {
    this.observers.forEach(observer => {
      observer.call();
    });
  }
}

8、中介者模式


9、访问者模式
让我们在不改变一个对象结构的前提下能够给对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。
Visitor Object：访问者对象，拥有一个 visit() 方法
Receiving Object：接收对象，拥有一个 accept() 方法
visit(receivingObj)：用于Visitor接收一个Receiving Object
accept(visitor)：用于Receving Object接收一个Visitor，并通过调用Visitor的 visit() 为其提供获取Receiving Object数据的能力
接受对象：
function Employee(name, salary) {
  this.name = name;
  this.salary = salary;
}

Employee.prototype = {
  getSalary: function () {
    return this.salary;
  },
  setSalary: function (salary) {
    this.salary = salary;
  },
  accept: function (visitor) {
    visitor.visit(this);
  }
}
访问者对象：
function Visitor() { }

Visitor.prototype = {
  visit: function (employee) {
    employee.setSalary(employee.getSalary() * 2);
  }
}
